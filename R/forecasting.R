####################################################################
#' ARIMA Forecast
#' 
#' This function automates the ARIMA iterations and modeling for 
#' time forecasting. For the moment, units can only be days.
#' 
#' @param time POSIX. Vector with date values
#' @param values Numeric. Vector with numerical values
#' @param n_future Integer. How many steps do you wish to forecast?
#' @param ARMA Integer. How many days should the model look backfor ARMA?
#' Between 7 and 10 days recommmended
#' @param wd_excluded Character vector. Which weekdays are excluded in 
#' your training set. If there are, please define know which ones. Example:
#' c('Sunday','Thursday')
#' @param plot Boolean. If you wish to plot your results
#' @param plot_days Integer. How many days back you wish to plot?
#' @param project Character. Name of your forecast project
#' @export
forecast_arima <- function(time, values, n_future = 30, 
                           ARMA = 8, wd_excluded = NA,
                           plot = TRUE, plot_days = 90,
                           project = NA){
  
  require(forecast)
  require(lubridate)
  
  arma <- c(1:ARMA)
  combs <- expand.grid(arma, arma)
  aic <- data.frame(
    AR = combs[,1], 
    MA = combs[,2], 
    cals = rep(0, nrow(combs)))
  
  # Which AR and MA minimize our AIC
  message("Iterating for best AR / MA combinations; there are ", ARMA*ARMA, "!")
  for(i in 1:nrow(aic)){
    Tmodel <- Arima(values, order = c(aic$AR[i], 1, aic$MA[i]))
    aic$cals[i] <- Tmodel$aic
  }
  AR <- aic$AR[which.min(aic$cals)]
  MA <- aic$MA[which.min(aic$cals)]
  message(paste("Best combination:", AR, "and", MA))
  aic_ARIMA <- min(aic$cals)
  model <- Arima(values, order = c(AR, 1, MA))
  train <- data.frame(time, values, 
                      pred = model$fitted, 
                      resid = model$residuals)
  
  # Forecast
  future_dates <- seq.Date(max(time) + 1, max(time) %m+% days(n_future), by=1)
  if (!is.na(wd_excluded)) {
    exclude <- lares::vector2text(wd_excluded, quotes = FALSE)
    future_dates <- future_dates[!weekdays(future_dates) %in% exclude]
    n_future <- length(future_dates)
  }
  f <- forecast(model, h = n_future)
  frows <- length(f$fitted)
  test <- data.frame(time = future_dates, pred = f$fitted[(frows-n_future+1):frows])
  
  # Outut list with all results
  output <- list(model = model,
                 metrics = accuracy(model),
                 forecast = test,
                 train = train)
  
  # Plot results
  if (nrow(train) > plot_days) {
    train <- train[1:plot_days, ] 
  }
  
  if (plot == TRUE) {
    require(ggplot2)
    plotdata <- data.frame(
      rbind(
        data.frame(date = train$time, values = train$values, type = "Real"),
        data.frame(date = train$time, values = train$pred, type = "Model"),
        data.frame(date = test$time, values = test$pred, type = "Forecast")
      ))
    rects <- data.frame(start = min(future_dates), end = max(future_dates))
    output$plot <- ggplot(plotdata, aes(date)) +
      geom_smooth(aes(y = values), method = 'loess', alpha = 0.5) +
      geom_line(aes(y = values, colour = type)) +
      labs(x = "Date", y = "Counter", colour = "") + 
      theme_minimal() + theme(legend.position = "top") +
      ggtitle("Real & Fitted Model vs Forecast (ARIMA)",
              subtitle = paste("Bias", signif(sum(train$resid)/nrow(train), 2), "|",
                               "MAE", signif(output$metrics[3], 3), "|",
                               "RMSE", signif(output$metrics[2], 3))) +
      scale_color_manual(values=c("orange", "navy","purple")) +
      geom_rect(data = rects, inherit.aes = FALSE, 
                aes(
                  xmin = start, xmax = end, 
                  ymin = min(plotdata$values),
                  ymax = max(plotdata$values)), 
                color = "transparent", fill = "grey", alpha = 0.25)
    if (!is.na(project)) {
      output$plot <- output$plot +
        labs(caption = project)
    }
    plot(output$plot)
  }
  
  return(output)
  
}


####################################################################
#' Machine Learning Forecast
#' 
#' This function lets the user create a forecast setting a time series
#' and a numerical value.
#' 
#' @param time POSIX. Vector with dates or time values
#' @param values Numeric. Vector with numerical values
#' @param n_future Integer. How many steps do you wish to forecast?
#' @param use_last Boolean. Use last observation?
#' @param plot Boolean. If you wish to plot your results
#' @param automl Boolean. Use lares::h2o_automl()
#' @param project Character. Name of your forecast project for plot title
#' @export
forecast_ml <- function(time, values, n_future = 15, use_last = TRUE, automl = FALSE, 
                        plot_forecast = TRUE, plot_model = FALSE,
                        project = "Simple Forecast using Machine Learning") {
  require(timetk)
  require(tidyquant)
  
  if (length(time) != length(values)) {
    stop("The parameters 'time' and 'values' should have the same length")
  }
  
  df <- data.frame(time = time, amount = values)
  if (use_last == FALSE) {
    df <- arrange(df, desc(time)) %>% slice(-1)
    n_future <- n_future + 1
  }
  
  # STEP 1: AUGMENT TIME SERIES SIGNATURE
  augmented <- df %>% tk_augment_timeseries_signature()
  augmented <- mutate(augmented, 
                      month.lbl = as.character(month.lbl),
                      wday.lbl = as.character(wday.lbl))
  
  # STEP 2: BUILD FUTURE (NEW) DATA
  idx <- augmented %>% tk_index()
  future_idx <- idx %>% tk_make_future_timeseries(n_future = n_future)
  new_data_tbl <- future_idx %>% tk_get_timeseries_signature() %>%
    mutate(month.lbl = as.character(month.lbl),
           wday.lbl = as.character(wday.lbl))
  
  # STEP 3: MODEL
  if (automl == FALSE) {
    fit_lm <- lm(amount ~ ., data = select(augmented, -c(time)))
    pred <- predict(fit_lm, newdata = select(new_data_tbl, -c(index)))
    predictions_tbl <- tibble(time = future_idx, amount = pred) 
  } else {
    augmented_h2o <- augmented %>% dplyr::rename(tag = amount)
    fit_auto <- lares::h2o_automl(df = augmented_h2o, alarm = FALSE, project = project)
    pred <- h2o.predict(fit_auto$model, as.h2o(new_data_tbl))
    predictions_tbl <- tibble(time = future_idx, amount = as.vector(pred))
  }
  
  # STEP 5: COMPARE ACTUAL VS PREDICTIONS
  rects <- data.frame(start = min(future_idx), end = max(future_idx))
  message("Predicted range: ", rects$start, " to ", rects$end)
  forecast <- df %>%
    ggplot(aes(x = time, y = amount)) + 
    labs(title = project, y = "Amount", x = "",
         subtitle = "Using simple multivariate regressions on time series with Machine Learning") +
    # Training data
    geom_line(color = palette_light()[[1]]) +
    geom_point(color = palette_light()[[1]]) +
    geom_smooth(method = 'loess', formula = 'y ~ x', alpha = 0.5) +
    # Predictions
    geom_line(aes(y = amount), color = palette_light()[[2]], data = predictions_tbl) +
    geom_point(aes(y = amount), color = palette_light()[[2]], data = predictions_tbl) +
    # Actuals
    geom_line(color = palette_light()[[1]], data = df) +
    geom_point(color = palette_light()[[1]], data = df) +
    # Aesthetics
    scale_x_date(date_breaks = "1 month", date_labels = "%b") +
    theme_tq() + 
    geom_rect(data = rects, inherit.aes = FALSE, 
              aes(
                xmin = start, xmax = end, ymin = 0,
                ymax = max(df$amount) * 1.02), 
              color = "transparent", fill = "orange", alpha = 0.3)
  
  if (plot_forecast == TRUE) {
    print(forecast)
  }
  
  if (plot_model == TRUE) {
    Sys.sleep(1)
    lares::mplot_full(
      tag = df$amount, 
      score = predictions_tbl$amount[1:length(df$amount)],
      subtitle = project)
    Sys.sleep(4)
  }
  
  df_final <- rbind(df, predictions_tbl)
  
  if (automl == TRUE) {
    model <- fit_auto
    score <- fit_auto$scores$score
  } else {
    model <- fit_lm
    score <- fit_lm$fitted.values
  }
  
  output <- list(data = df_final, 
                 model = model, 
                 errors = lares::errors(df$amount, score))
  
  return(output)
  
}
